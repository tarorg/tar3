/*! Capacitor: https://capacitorjs.com/ - MIT License */const te=i=>{const e=new Map;e.set("web",{name:"web"});const t=i.CapacitorPlatforms||{currentPlatform:{name:"web"},platforms:e},r=(s,a)=>{t.platforms.set(s,a)},n=s=>{t.platforms.has(s)&&(t.currentPlatform=t.platforms.get(s))};return t.addPlatform=r,t.setPlatform=n,t},re=i=>i.CapacitorPlatforms=te(i),F=re(typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});F.addPlatform;F.setPlatform;var q;(function(i){i.Unimplemented="UNIMPLEMENTED",i.Unavailable="UNAVAILABLE"})(q||(q={}));class _ extends Error{constructor(e,t,r){super(e),this.message=e,this.code=t,this.data=r}}const se=i=>{var e,t;return i?.androidBridge?"android":!((t=(e=i?.webkit)===null||e===void 0?void 0:e.messageHandlers)===null||t===void 0)&&t.bridge?"ios":"web"},ne=i=>{var e,t,r,n,s;const a=i.CapacitorCustomPlatform||null,o=i.Capacitor||{},c=o.Plugins=o.Plugins||{},l=i.CapacitorPlatforms,E=()=>a!==null?a.name:se(i),m=((e=l?.currentPlatform)===null||e===void 0?void 0:e.getPlatform)||E,L=()=>m()!=="web",x=((t=l?.currentPlatform)===null||t===void 0?void 0:t.isNativePlatform)||L,Q=d=>{const u=k.get(d);return!!(u?.platforms.has(m())||R(d))},G=((r=l?.currentPlatform)===null||r===void 0?void 0:r.isPluginAvailable)||Q,J=d=>{var u;return(u=o.PluginHeaders)===null||u===void 0?void 0:u.find(C=>C.name===d)},R=((n=l?.currentPlatform)===null||n===void 0?void 0:n.getPluginHeader)||J,K=d=>i.console.error(d),V=(d,u,C)=>Promise.reject(`${C} does not have an implementation of "${u}".`),k=new Map,X=(d,u={})=>{const C=k.get(d);if(C)return console.warn(`Capacitor plugin "${d}" already registered. Cannot register plugins twice.`),C.proxy;const v=m(),j=R(d);let w;const Y=async()=>(!w&&v in u?w=typeof u[v]=="function"?w=await u[v]():w=u[v]:a!==null&&!w&&"web"in u&&(w=typeof u.web=="function"?w=await u.web():w=u.web),w),Z=(h,y)=>{var P,g;if(j){const b=j?.methods.find(f=>y===f.name);if(b)return b.rtype==="promise"?f=>o.nativePromise(d,y.toString(),f):(f,S)=>o.nativeCallback(d,y.toString(),f,S);if(h)return(P=h[y])===null||P===void 0?void 0:P.bind(h)}else{if(h)return(g=h[y])===null||g===void 0?void 0:g.bind(h);throw new _(`"${d}" plugin is not implemented on ${v}`,q.Unimplemented)}},D=h=>{let y;const P=(...g)=>{const b=Y().then(f=>{const S=Z(f,h);if(S){const T=S(...g);return y=T?.remove,T}else throw new _(`"${d}.${h}()" is not implemented on ${v}`,q.Unimplemented)});return h==="addListener"&&(b.remove=async()=>y()),b};return P.toString=()=>`${h.toString()}() { [capacitor code] }`,Object.defineProperty(P,"name",{value:h,writable:!1,configurable:!1}),P},$=D("addListener"),M=D("removeListener"),ee=(h,y)=>{const P=$({eventName:h},y),g=async()=>{const f=await P;M({eventName:h,callbackId:f},y)},b=new Promise(f=>P.then(()=>f({remove:g})));return b.remove=async()=>{console.warn("Using addListener() without 'await' is deprecated."),await g()},b},N=new Proxy({},{get(h,y){switch(y){case"$$typeof":return;case"toJSON":return()=>({});case"addListener":return j?ee:$;case"removeListener":return M;default:return D(y)}}});return c[d]=N,k.set(d,{name:d,proxy:N,platforms:new Set([...Object.keys(u),...j?[v]:[]])}),N},z=((s=l?.currentPlatform)===null||s===void 0?void 0:s.registerPlugin)||X;return o.convertFileSrc||(o.convertFileSrc=d=>d),o.getPlatform=m,o.handleError=K,o.isNativePlatform=x,o.isPluginAvailable=G,o.pluginMethodNoop=V,o.registerPlugin=z,o.Exception=_,o.DEBUG=!!o.DEBUG,o.isLoggingEnabled=!!o.isLoggingEnabled,o.platform=o.getPlatform(),o.isNative=o.isNativePlatform(),o},ie=i=>i.Capacitor=ne(i),p=ie(typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{}),A=p.registerPlugin;p.Plugins;class H{constructor(e){this.listeners={},this.retainedEventArguments={},this.windowListeners={},e&&(console.warn(`Capacitor WebPlugin "${e.name}" config object was deprecated in v3 and will be removed in v4.`),this.config=e)}addListener(e,t){let r=!1;this.listeners[e]||(this.listeners[e]=[],r=!0),this.listeners[e].push(t);const s=this.windowListeners[e];s&&!s.registered&&this.addWindowListener(s),r&&this.sendRetainedArgumentsForEvent(e);const a=async()=>this.removeListener(e,t);return Promise.resolve({remove:a})}async removeAllListeners(){this.listeners={};for(const e in this.windowListeners)this.removeWindowListener(this.windowListeners[e]);this.windowListeners={}}notifyListeners(e,t,r){const n=this.listeners[e];if(!n){if(r){let s=this.retainedEventArguments[e];s||(s=[]),s.push(t),this.retainedEventArguments[e]=s}return}n.forEach(s=>s(t))}hasListeners(e){return!!this.listeners[e].length}registerWindowListener(e,t){this.windowListeners[t]={registered:!1,windowEventName:e,pluginEventName:t,handler:r=>{this.notifyListeners(t,r)}}}unimplemented(e="not implemented"){return new p.Exception(e,q.Unimplemented)}unavailable(e="not available"){return new p.Exception(e,q.Unavailable)}async removeListener(e,t){const r=this.listeners[e];if(!r)return;const n=r.indexOf(t);this.listeners[e].splice(n,1),this.listeners[e].length||this.removeWindowListener(this.windowListeners[e])}addWindowListener(e){window.addEventListener(e.windowEventName,e.handler),e.registered=!0}removeWindowListener(e){e&&(window.removeEventListener(e.windowEventName,e.handler),e.registered=!1)}sendRetainedArgumentsForEvent(e){const t=this.retainedEventArguments[e];t&&(delete this.retainedEventArguments[e],t.forEach(r=>{this.notifyListeners(e,r)}))}}const U=i=>encodeURIComponent(i).replace(/%(2[346B]|5E|60|7C)/g,decodeURIComponent).replace(/[()]/g,escape),I=i=>i.replace(/(%[\dA-F]{2})+/gi,decodeURIComponent);class oe extends H{async getCookies(){const e=document.cookie,t={};return e.split(";").forEach(r=>{if(r.length<=0)return;let[n,s]=r.replace(/=/,"CAP_COOKIE").split("CAP_COOKIE");n=I(n).trim(),s=I(s).trim(),t[n]=s}),t}async setCookie(e){try{const t=U(e.key),r=U(e.value),n=`; expires=${(e.expires||"").replace("expires=","")}`,s=(e.path||"/").replace("path=",""),a=e.url!=null&&e.url.length>0?`domain=${e.url}`:"";document.cookie=`${t}=${r||""}${n}; path=${s}; ${a};`}catch(t){return Promise.reject(t)}}async deleteCookie(e){try{document.cookie=`${e.key}=; Max-Age=0`}catch(t){return Promise.reject(t)}}async clearCookies(){try{const e=document.cookie.split(";")||[];for(const t of e)document.cookie=t.replace(/^ +/,"").replace(/=.*/,`=;expires=${new Date().toUTCString()};path=/`)}catch(e){return Promise.reject(e)}}async clearAllCookies(){try{await this.clearCookies()}catch(e){return Promise.reject(e)}}}A("CapacitorCookies",{web:()=>new oe});const ae=async i=>new Promise((e,t)=>{const r=new FileReader;r.onload=()=>{const n=r.result;e(n.indexOf(",")>=0?n.split(",")[1]:n)},r.onerror=n=>t(n),r.readAsDataURL(i)}),ce=(i={})=>{const e=Object.keys(i);return Object.keys(i).map(n=>n.toLocaleLowerCase()).reduce((n,s,a)=>(n[s]=i[e[a]],n),{})},le=(i,e=!0)=>i?Object.entries(i).reduce((r,n)=>{const[s,a]=n;let o,c;return Array.isArray(a)?(c="",a.forEach(l=>{o=e?encodeURIComponent(l):l,c+=`${s}=${o}&`}),c.slice(0,-1)):(o=e?encodeURIComponent(a):a,c=`${s}=${o}`),`${r}&${c}`},"").substr(1):null,de=(i,e={})=>{const t=Object.assign({method:i.method||"GET",headers:i.headers},e),n=ce(i.headers)["content-type"]||"";if(typeof i.data=="string")t.body=i.data;else if(n.includes("application/x-www-form-urlencoded")){const s=new URLSearchParams;for(const[a,o]of Object.entries(i.data||{}))s.set(a,o);t.body=s.toString()}else if(n.includes("multipart/form-data")||i.data instanceof FormData){const s=new FormData;if(i.data instanceof FormData)i.data.forEach((o,c)=>{s.append(c,o)});else for(const o of Object.keys(i.data))s.append(o,i.data[o]);t.body=s;const a=new Headers(t.headers);a.delete("content-type"),t.headers=a}else(n.includes("application/json")||typeof i.data=="object")&&(t.body=JSON.stringify(i.data));return t};class ue extends H{async request(e){const t=de(e,e.webFetchExtra),r=le(e.params,e.shouldEncodeUrlParams),n=r?`${e.url}?${r}`:e.url,s=await fetch(n,t),a=s.headers.get("content-type")||"";let{responseType:o="text"}=s.ok?e:{};a.includes("application/json")&&(o="json");let c,l;switch(o){case"arraybuffer":case"blob":l=await s.blob(),c=await ae(l);break;case"json":c=await s.json();break;case"document":case"text":default:c=await s.text()}const E={};return s.headers.forEach((m,L)=>{E[L]=m}),{data:c,headers:E,status:s.status,url:s.url}}async get(e){return this.request(Object.assign(Object.assign({},e),{method:"GET"}))}async post(e){return this.request(Object.assign(Object.assign({},e),{method:"POST"}))}async put(e){return this.request(Object.assign(Object.assign({},e),{method:"PUT"}))}async patch(e){return this.request(Object.assign(Object.assign({},e),{method:"PATCH"}))}async delete(e){return this.request(Object.assign(Object.assign({},e),{method:"DELETE"}))}}A("CapacitorHttp",{web:()=>new ue});const he="modulepreload",me=function(i){return"/"+i},B={},ye=function(e,t,r){let n=Promise.resolve();if(t&&t.length>0){document.getElementsByTagName("link");const a=document.querySelector("meta[property=csp-nonce]"),o=a?.nonce||a?.getAttribute("nonce");n=Promise.allSettled(t.map(c=>{if(c=me(c),c in B)return;B[c]=!0;const l=c.endsWith(".css"),E=l?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${c}"]${E}`))return;const m=document.createElement("link");if(m.rel=l?"stylesheet":he,l||(m.as="script"),m.crossOrigin="",m.href=c,o&&m.setAttribute("nonce",o),document.head.appendChild(m),l)return new Promise((L,x)=>{m.addEventListener("load",L),m.addEventListener("error",()=>x(new Error(`Unable to preload CSS for ${c}`)))})}))}function s(a){const o=new Event("vite:preloadError",{cancelable:!0});if(o.payload=a,window.dispatchEvent(o),!o.defaultPrevented)throw a}return n.then(a=>{for(const o of a||[])o.status==="rejected"&&s(o.reason);return e().catch(s)})};class fe{constructor(e){this.sqlite=e,this._connectionDict=new Map}async initWebStore(){try{return await this.sqlite.initWebStore(),Promise.resolve()}catch(e){return Promise.reject(e)}}async saveToStore(e){try{return await this.sqlite.saveToStore({database:e}),Promise.resolve()}catch(t){return Promise.reject(t)}}async saveToLocalDisk(e){try{return await this.sqlite.saveToLocalDisk({database:e}),Promise.resolve()}catch(t){return Promise.reject(t)}}async getFromLocalDiskToStore(e){const t=e??!0;try{return await this.sqlite.getFromLocalDiskToStore({overwrite:t}),Promise.resolve()}catch(r){return Promise.reject(r)}}async echo(e){try{const t=await this.sqlite.echo({value:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isSecretStored(){try{const e=await this.sqlite.isSecretStored();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async setEncryptionSecret(e){try{return await this.sqlite.setEncryptionSecret({passphrase:e}),Promise.resolve()}catch(t){return Promise.reject(t)}}async changeEncryptionSecret(e,t){try{return await this.sqlite.changeEncryptionSecret({passphrase:e,oldpassphrase:t}),Promise.resolve()}catch(r){return Promise.reject(r)}}async clearEncryptionSecret(){try{return await this.sqlite.clearEncryptionSecret(),Promise.resolve()}catch(e){return Promise.reject(e)}}async checkEncryptionSecret(e){try{const t=await this.sqlite.checkEncryptionSecret({passphrase:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async addUpgradeStatement(e,t){try{return e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.addUpgradeStatement({database:e,upgrade:t}),Promise.resolve()}catch(r){return Promise.reject(r)}}async createConnection(e,t,r,n,s){try{e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.createConnection({database:e,encrypted:t,mode:r,version:n,readonly:s});const a=new W(e,s,this.sqlite),o=s?`RO_${e}`:`RW_${e}`;return this._connectionDict.set(o,a),Promise.resolve(a)}catch(a){return Promise.reject(a)}}async closeConnection(e,t){try{e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.closeConnection({database:e,readonly:t});const r=t?`RO_${e}`:`RW_${e}`;return this._connectionDict.delete(r),Promise.resolve()}catch(r){return Promise.reject(r)}}async isConnection(e,t){const r={};e.endsWith(".db")&&(e=e.slice(0,-3));const n=t?`RO_${e}`:`RW_${e}`;return r.result=this._connectionDict.has(n),Promise.resolve(r)}async retrieveConnection(e,t){e.endsWith(".db")&&(e=e.slice(0,-3));const r=t?`RO_${e}`:`RW_${e}`;if(this._connectionDict.has(r)){const n=this._connectionDict.get(r);return typeof n<"u"?Promise.resolve(n):Promise.reject(`Connection ${e} is undefined`)}else return Promise.reject(`Connection ${e} does not exist`)}async getNCDatabasePath(e,t){try{const r=await this.sqlite.getNCDatabasePath({path:e,database:t});return Promise.resolve(r)}catch(r){return Promise.reject(r)}}async createNCConnection(e,t){try{await this.sqlite.createNCConnection({databasePath:e,version:t});const r=new W(e,!0,this.sqlite),n=`RO_${e})`;return this._connectionDict.set(n,r),Promise.resolve(r)}catch(r){return Promise.reject(r)}}async closeNCConnection(e){try{await this.sqlite.closeNCConnection({databasePath:e});const t=`RO_${e})`;return this._connectionDict.delete(t),Promise.resolve()}catch(t){return Promise.reject(t)}}async isNCConnection(e){const t={},r=`RO_${e})`;return t.result=this._connectionDict.has(r),Promise.resolve(t)}async retrieveNCConnection(e){if(this._connectionDict.has(e)){const t=`RO_${e})`,r=this._connectionDict.get(t);return typeof r<"u"?Promise.resolve(r):Promise.reject(`Connection ${e} is undefined`)}else return Promise.reject(`Connection ${e} does not exist`)}async isNCDatabase(e){try{const t=await this.sqlite.isNCDatabase({databasePath:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async retrieveAllConnections(){return this._connectionDict}async closeAllConnections(){const e=new Map;try{for(const t of this._connectionDict.keys()){const r=t.substring(3),n=t.substring(0,3)==="RO_";await this.sqlite.closeConnection({database:r,readonly:n}),e.set(t,null)}for(const t of e.keys())this._connectionDict.delete(t);return Promise.resolve()}catch(t){return Promise.reject(t)}}async checkConnectionsConsistency(){try{const e=[...this._connectionDict.keys()],t=[],r=[];for(const s of e)t.push(s.substring(0,2)),r.push(s.substring(3));const n=await this.sqlite.checkConnectionsConsistency({dbNames:r,openModes:t});return n.result||(this._connectionDict=new Map),Promise.resolve(n)}catch(e){return this._connectionDict=new Map,Promise.reject(e)}}async importFromJson(e){try{const t=await this.sqlite.importFromJson({jsonstring:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isJsonValid(e){try{const t=await this.sqlite.isJsonValid({jsonstring:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async copyFromAssets(e){const t=e??!0;try{return await this.sqlite.copyFromAssets({overwrite:t}),Promise.resolve()}catch(r){return Promise.reject(r)}}async getFromHTTPRequest(e,t){const r=t??!0;try{return await this.sqlite.getFromHTTPRequest({url:e,overwrite:r}),Promise.resolve()}catch(n){return Promise.reject(n)}}async isDatabaseEncrypted(e){e.endsWith(".db")&&(e=e.slice(0,-3));try{const t=await this.sqlite.isDatabaseEncrypted({database:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isInConfigEncryption(){try{const e=await this.sqlite.isInConfigEncryption();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isInConfigBiometricAuth(){try{const e=await this.sqlite.isInConfigBiometricAuth();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isDatabase(e){e.endsWith(".db")&&(e=e.slice(0,-3));try{const t=await this.sqlite.isDatabase({database:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async getDatabaseList(){try{const t=(await this.sqlite.getDatabaseList()).values;t.sort();const r={values:t};return Promise.resolve(r)}catch(e){return Promise.reject(e)}}async getMigratableDbList(e){const t=e||"default";try{const r=await this.sqlite.getMigratableDbList({folderPath:t});return Promise.resolve(r)}catch(r){return Promise.reject(r)}}async addSQLiteSuffix(e,t){const r=e||"default",n=t||[];try{const s=await this.sqlite.addSQLiteSuffix({folderPath:r,dbNameList:n});return Promise.resolve(s)}catch(s){return Promise.reject(s)}}async deleteOldDatabases(e,t){const r=e||"default",n=t||[];try{const s=await this.sqlite.deleteOldDatabases({folderPath:r,dbNameList:n});return Promise.resolve(s)}catch(s){return Promise.reject(s)}}async moveDatabasesAndAddSuffix(e,t){const r=e||"default",n=t||[];return this.sqlite.moveDatabasesAndAddSuffix({folderPath:r,dbNameList:n})}}class W{constructor(e,t,r){this.dbName=e,this.readonly=t,this.sqlite=r}getConnectionDBName(){return this.dbName}getConnectionReadOnly(){return this.readonly}async open(){try{return await this.sqlite.open({database:this.dbName,readonly:this.readonly}),Promise.resolve()}catch(e){return Promise.reject(e)}}async close(){try{return await this.sqlite.close({database:this.dbName,readonly:this.readonly}),Promise.resolve()}catch(e){return Promise.reject(e)}}async beginTransaction(){try{const e=await this.sqlite.beginTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async commitTransaction(){try{const e=await this.sqlite.commitTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async rollbackTransaction(){try{const e=await this.sqlite.rollbackTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isTransactionActive(){try{const e=await this.sqlite.isTransactionActive({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async loadExtension(e){try{return await this.sqlite.loadExtension({database:this.dbName,path:e,readonly:this.readonly}),Promise.resolve()}catch(t){return Promise.reject(t)}}async enableLoadExtension(e){try{return await this.sqlite.enableLoadExtension({database:this.dbName,toggle:e,readonly:this.readonly}),Promise.resolve()}catch(t){return Promise.reject(t)}}async getUrl(){try{const e=await this.sqlite.getUrl({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async getVersion(){try{const e=await this.sqlite.getVersion({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async getTableList(){try{const e=await this.sqlite.getTableList({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async execute(e,t=!0,r=!0){try{if(this.readonly)return Promise.reject("not allowed in read-only mode");{const n=await this.sqlite.execute({database:this.dbName,statements:e,transaction:t,readonly:!1,isSQL92:r});return Promise.resolve(n)}}catch(n){return Promise.reject(n)}}async query(e,t,r=!0){let n;try{return t&&t.length>0?n=await this.sqlite.query({database:this.dbName,statement:e,values:t,readonly:this.readonly,isSQL92:!0}):n=await this.sqlite.query({database:this.dbName,statement:e,values:[],readonly:this.readonly,isSQL92:r}),n=await this.reorderRows(n),Promise.resolve(n)}catch(s){return Promise.reject(s)}}async run(e,t,r=!0,n="no",s=!0){let a;try{return this.readonly?Promise.reject("not allowed in read-only mode"):(t&&t.length>0?a=await this.sqlite.run({database:this.dbName,statement:e,values:t,transaction:r,readonly:!1,returnMode:n,isSQL92:!0}):a=await this.sqlite.run({database:this.dbName,statement:e,values:[],transaction:r,readonly:!1,returnMode:n,isSQL92:s}),a.changes=await this.reorderRows(a.changes),Promise.resolve(a))}catch(o){return Promise.reject(o)}}async executeSet(e,t=!0,r="no",n=!0){let s;try{return this.readonly?Promise.reject("not allowed in read-only mode"):(s=await this.sqlite.executeSet({database:this.dbName,set:e,transaction:t,readonly:!1,returnMode:r,isSQL92:n}),s.changes=await this.reorderRows(s.changes),Promise.resolve(s))}catch(a){return Promise.reject(a)}}async isExists(){try{const e=await this.sqlite.isDBExists({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isTable(e){try{const t=await this.sqlite.isTableExists({database:this.dbName,table:e,readonly:this.readonly});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isDBOpen(){try{const e=await this.sqlite.isDBOpen({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async delete(){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(await this.sqlite.deleteDatabase({database:this.dbName,readonly:!1}),Promise.resolve())}catch(e){return Promise.reject(e)}}async createSyncTable(){try{if(this.readonly)return Promise.reject("not allowed in read-only mode");{const e=await this.sqlite.createSyncTable({database:this.dbName,readonly:!1});return Promise.resolve(e)}}catch(e){return Promise.reject(e)}}async setSyncDate(e){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(await this.sqlite.setSyncDate({database:this.dbName,syncdate:e,readonly:!1}),Promise.resolve())}catch(t){return Promise.reject(t)}}async getSyncDate(){try{const e=await this.sqlite.getSyncDate({database:this.dbName,readonly:this.readonly});let t="";return e.syncDate>0&&(t=new Date(e.syncDate*1e3).toISOString()),Promise.resolve(t)}catch(e){return Promise.reject(e)}}async exportToJson(e,t=!1){try{const r=await this.sqlite.exportToJson({database:this.dbName,jsonexportmode:e,readonly:this.readonly,encrypted:t});return Promise.resolve(r)}catch(r){return Promise.reject(r)}}async deleteExportedRows(){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(await this.sqlite.deleteExportedRows({database:this.dbName,readonly:!1}),Promise.resolve())}catch(e){return Promise.reject(e)}}async executeTransaction(e,t=!0){let r=0,n=!1;if(this.readonly)return Promise.reject("not allowed in read-only mode");if(await this.sqlite.beginTransaction({database:this.dbName}),n=await this.sqlite.isTransactionActive({database:this.dbName}),!n)return Promise.reject("After Begin Transaction, no transaction active");try{for(const o of e){if(typeof o!="object"||!("statement"in o))throw new Error("Error a task.statement must be provided");if("values"in o&&o.values&&o.values.length>0){const c=o.statement.toUpperCase().includes("RETURNING")?"all":"no",l=await this.sqlite.run({database:this.dbName,statement:o.statement,values:o.values,transaction:!1,readonly:!1,returnMode:c,isSQL92:t});if(l.changes.changes<0)throw new Error("Error in transaction method run ");r+=l.changes.changes}else{const c=await this.sqlite.execute({database:this.dbName,statements:o.statement,transaction:!1,readonly:!1});if(c.changes.changes<0)throw new Error("Error in transaction method execute ");r+=c.changes.changes}}const s=await this.sqlite.commitTransaction({database:this.dbName});r+=s.changes.changes;const a={changes:{changes:r}};return Promise.resolve(a)}catch(s){const a=s.message?s.message:s;return await this.sqlite.rollbackTransaction({database:this.dbName}),Promise.reject(a)}}async reorderRows(e){const t=e;if(e?.values&&typeof e.values[0]=="object"&&Object.keys(e.values[0]).includes("ios_columns")){const r=e.values[0].ios_columns,n=[];for(let s=1;s<e.values.length;s++){const a=e.values[s],o={};for(const c of r)o[c]=a[c];n.push(o)}t.values=n}return Promise.resolve(t)}}const Pe=A("CapacitorSQLite",{web:()=>ye(()=>import("./web.DB7OxLjv.js"),[]).then(i=>new i.CapacitorSQLiteWeb),electron:()=>window.CapacitorCustomPlatform.plugins.CapacitorSQLite});class we{sqlite=null;db=null;async init(){typeof window<"u"&&(p.isNativePlatform()?await this.initSQLite():await this.initIndexedDB())}async initSQLite(){this.sqlite=new fe(Pe);const e=await this.sqlite.createConnection("mydb",!1,"no-encryption",1);await e.open(),this.db=e,await this.db.execute({statements:`
      CREATE TABLE IF NOT EXISTS links (id INTEGER PRIMARY KEY AUTOINCREMENT, title TEXT, url TEXT, icon TEXT);
      CREATE TABLE IF NOT EXISTS tar_boxes (id INTEGER PRIMARY KEY AUTOINCREMENT, title TEXT, url TEXT);
    `})}async initIndexedDB(){return new Promise((e,t)=>{const r=window.indexedDB.open("mydb",1);r.onerror=()=>t(r.error),r.onsuccess=()=>{this.db=r.result,e()},r.onupgradeneeded=n=>{const s=n.target.result;s.createObjectStore("links",{keyPath:"id",autoIncrement:!0}),s.createObjectStore("tar_boxes",{keyPath:"id",autoIncrement:!0})}})}async getLinks(){return typeof window>"u"?[]:p.isNativePlatform()?(await this.db.query("SELECT * FROM links")).values:new Promise((e,t)=>{const s=this.db.transaction(["links"],"readonly").objectStore("links").getAll();s.onerror=()=>t(s.error),s.onsuccess=()=>e(s.result)})}async getTarBoxes(){return typeof window>"u"?[]:p.isNativePlatform()?(await this.db.query("SELECT * FROM tar_boxes")).values:new Promise((e,t)=>{const s=this.db.transaction(["tar_boxes"],"readonly").objectStore("tar_boxes").getAll();s.onerror=()=>t(s.error),s.onsuccess=()=>e(s.result)})}}const O=new we;async function ge(){await O.init();const i=await O.getLinks(),e=await O.getTarBoxes(),t=document.getElementById("social-links"),r=document.getElementById("tar-boxes");t&&i.forEach(n=>{const s=document.createElement("a");s.href=n.url,s.target="_blank",s.rel="noopener noreferrer",s.className="text-gray-400 hover:text-gray-600 transition-colors duration-300",s.title=n.title,s.innerHTML=`<svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                    ${be(n.icon)}
                </svg>`,t.appendChild(s)}),r&&e.forEach(n=>{const s=document.createElement("a");s.href=n.url,s.className="bg-gray-100 rounded-lg p-4 text-center hover:bg-gray-200 transition duration-300",s.innerHTML=`<span class="text-gray-700">${n.title}</span>`,r.appendChild(s)})}function be(i){return i==="github"?'<path fill-rule="evenodd" d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.695-4.566 4.943.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0022 12.017C22 6.484 17.522 2 12 2z" clip-rule="evenodd" />':""}ge();export{H as W};
